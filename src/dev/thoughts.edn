(ns thoughts)

(comment
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; DATABASE SCHEMA
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defmacro defschema [nm & args])

  ;; I expect this to be an extensible map system. some things talk specifically about
  ;; database concerns, while others specifically address things like authorization.
  ;; GOAL: Make everything IDE navigable (declare syms for things).  Syntax might be more
  ;; like clojure spec, so that each kw is more navigable?
  ;; The following indicate a grouping of attributes into a database "entity" (doc/table).
  ;; The keywords generated would actually be com.example.schema.account/id, etc.
  (defschema account
    ;; probably declare what things correlate with authentication?
    {:id            {:db/type          :db.type/uuid
                     :db/authorization :contextual-identity
                     :db/unique        :db.unique/identity}
     :role          {:db/type #{:user :admin :support}}
     :name          {:db/type :db.type/string}
     :password      {:db/type :db.type/authorization-password}
     :ssn           {:db/type              :db.type/string
                     ;; list of things that must be in the authorization context to evaluate authorization
                     :db/requires-contexts #{:account/id :account/role}

                     ;; lambda for evaluating access to data. Receives the contexts required.
                     ;; In this example if the context (of auth) says you are logged in with an
                     ;; account ID that matches the account ID of the entity being read, then you
                     ;; are allowed to access it.
                     ;; Such a field-level access control commonly would be enforce by a resolver, which
                     ;; could simply return a well-known value for the attr `::auth/denied` so that the UI
                     ;; could then elide the data in the form.
                     ;; Return values for this function could work with a pluggable system...say
                     ;; you set up `:filtered` to mean read through the filter predicate.
                     :db/authorization     (fn [context entity]
                                             (cond
                                               (= (:account/id entity) (:account/id context)) :read-write
                                               (= :admin (:account/role context)) :read-write
                                               (= :support (:account/role context)) :filtered
                                               :otherwise :none))
                     :db/filter-predicate  {:account/ssn (fn [ssn] (redact-all-but-last-4 ssn))}}
     :phone-numbers {:db/type      :db.type/ref
                     :db/component true
                     :references   :phone/id}})

  ;; alt syntax (one entity per model file)
  (rad/attr ::id {...})
  (rad/attr ::role {...})

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; RELATIONS
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; In SQL, a to-many is modelled from child -> parent id, in Datomic (and others)
  ;; it is the opposite.  The opinion of Fulcro is that the parent can have an edge
  ;; in the "virtual graph" in either direction (though there may be some expense in
  ;; the computation).  The edge is modelled from parent to child.  Schema generation
  ;; for SQL generates the expected reverse FK, and generated resolvers simple satisfy
  ;; it as needed.

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; VIRTUAL PROPERTIES
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; Virtual properties can be declared with respect to the context in which they
  ;; can be generated, along with additional data that might need to be in
  ;; context for them to work (e.g. parameters).
  (rad/attr ::employee/hours-worked-in-period
    {:virtual?        true
     :resolver/input  #{:employee/id :local/start-date :local/end-date}
     :resolver/batch? true
     :calculation     (fn [input]
                        (if (sequential? input)
                          (resolve-many input)
                          (resolve-one input)))})

  ;; == TOOLS FOR DEVELOPMENT:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; DATABASE WORKFLOW
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; At REPL: writes a migration to your configured data migrations
  (migrate-up config account)

  ;; Takes a picture of the current schema, and saves it to a state file (like package-lock.json, but
  ;; can be simple EDN)
  (freeze-schema config)

  ;; Next propsal uses frozen state to make a diff and figure out if an evolution is safe based on change.
  ;; If so, emits a migration to cause the evolution. This keeps the schema in one declarative place,
  ;; but allows for safe migration of existing systems over time.
  (migrate-up config account)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; RESOLVER WORKFLOW
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; generate all of the resolvers necessary for entity attribute reads/writes, with
  ;; auth/security already built-in.
  (generate-pathom-crud)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; RUNTIME
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; BUILT-IN part of RAD:
  (defstatemachine auth-context-machine
    ;; Keeps track of various ways you have authenticated
    )

  ;; FOR SOME GIVEN CONTEXT IN UI:
  ;;  A top-level state machine manages any given screen's lifecycle

  ;; 1. URL comes in for /account/edit/1
  ;; 2. Declarative config figures out what that means, looks at query:
  ;;   a. Figures out if sufficient auth
  ;;   b. At dev time: figures out if query is even satisfiable (i.e. gives errors about reachability)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; UI
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; Define what goes together in a form, and various aspects of how those things behave.
  ;; Open map that could include things like instructions about layout.
  ;; Validation could be local, or declared in attr schema.
  (defform phone-number-form [this props]
    {:rad/fields           {:phone/number {:validator matches-phone-number}
                            :phone/type   {:values :db/enumeration}}
     :to-many.layout/style :inline})

  (defform basic-account [this props]
    {:rad/fields {:account/name          {:validator non-empty-string}
                  :account/phone-numbers {:min-count 0
                                          :max-count 3
                                          :subform   phone-number-form}}}
    ;; no body means "render a reasonable default"
    )

  (defreport hours-worked [this props]
    {;; local input indicates that the report needs to collect data from the user in order to run the
     ;; report
     :params  #{:local/date}
     :input   #{:local/date :employee/first-name :employee/last-name :employee/hours-worked-this-week}
     :rows    :employee/active-employees                    ; resolver finds the list of :employee/id, and can then resolve rows
     ;; headers chould be predefined for attrs in schema, or overridden here
     :headers ["Name" "Hours Worked"]
     :columns [:employee/full-name :employee/hours-worked-this-week]}
    ;; empty body means render something "reasonable", but the data is in props, so you can
    ;; customize it. Also (rad/report this props) would be the table, so you could wrap the
    ;; automated UI
    )

  )
