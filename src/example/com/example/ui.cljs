(ns com.example.ui
  (:require
    [com.example.model.account :as acct]
    [com.example.ui.login-dialog :refer [LoginForm]]
    [com.fulcrologic.semantic-ui.modules.modal.ui-modal :refer [ui-modal]]
    [com.fulcrologic.semantic-ui.modules.modal.ui-modal-header :refer [ui-modal-header]]
    [com.fulcrologic.semantic-ui.modules.modal.ui-modal-content :refer [ui-modal-content]]
    [com.fulcrologic.rad :as rad]
    [com.fulcrologic.rad.form :as form]
    [com.fulcrologic.rad.controller :as controller]
    [com.fulcrologic.rad.authorization :as auth]
    [com.fulcrologic.rad.attributes :as attr]
    [com.fulcrologic.fulcro.algorithms.normalized-state :as fns]
    [com.fulcrologic.fulcro.components :as comp :refer [defsc]]
    [com.fulcrologic.fulcro.mutations :as m :refer [defmutation]]
    [com.fulcrologic.fulcro.routing.dynamic-routing :as dr :refer [defrouter]]
    [com.fulcrologic.fulcro.dom :as dom :refer [div label input]]
    [com.fulcrologic.fulcro.ui-state-machines :as uism :refer [defstatemachine]]
    [taoensso.timbre :as log]
    [com.fulcrologic.fulcro.mutations :as m]
    [clojure.set :as set]
    [com.fulcrologic.fulcro.data-fetch :as df]
    [com.fulcrologic.fulcro.algorithms.merge :as merge]
    [com.fulcrologic.fulcro.algorithms.form-state :as fs]))

(defsc AccountForm [this props]
  {
   ::attr/attributes   [acct/id acct/name]

   ;; intention is action can be "edit", "create", "view". ID can be the real ID, or some constant for create (so
   ;; bookmarking works?).
   ;; Could also use new tempid on create and do a check for existence
   :route-segment      ["account" :action :id]
   :will-enter         (fn [app {:keys [id]}] (dr/route-immediate [::acct/id id]))

   ::rad/start-edit!   (fn [app {:rad/keys [id target-route]}]
                         (log/info "START ACCOUNT EDIT")
                         (let [id (uuid id)]
                           (df/load! app [::acct/id id] AccountForm
                             {:post-action (fn [{:keys [state]}]
                                             (log/info "Marking the form complete")
                                             (fns/swap!-> state
                                               (assoc-in [::acct/id id :ui/new?] false)
                                               (fs/mark-complete* [::acct/id id]))
                                             (controller/io-complete! app target-route))})))

   ;; TODO: ID generation pluggable? Use tempids?  NOTE: The controller has to generate the ID because the incoming
   ;; route is already determined
   ::rad/start-create! (fn [app {::rad/keys [target-route tempid]}]
                         (log/info "START ACCOUNT CREATE")
                         (let [ident         [::acct/id tempid]
                               fields        (comp/component-options AccountForm ::attr/attributes)
                               initial-value (into {:ui/new? true}
                                               (keep (fn [{::attr/keys [qualified-key default-value unique]}]
                                                       (cond
                                                         (= unique :identity) [qualified-key tempid]
                                                         default-value [qualified-key default-value])))
                                               fields)
                               filled-fields (keys initial-value)
                               tx            (into []
                                               (map (fn [k]
                                                      (fs/mark-complete! {:entity-ident ident
                                                                          :field        k})))
                                               filled-fields)]
                           (merge/merge-component! app AccountForm initial-value)
                           (when (seq tx)
                             (log/info "Marking fields with default values complete")
                             (comp/transact! app tx))
                           (controller/io-complete! app target-route)))

   :pre-merge          (fn [{:keys [data-tree]}]
                         (fs/add-form-config AccountForm data-tree))

   ;; TODO: Derive query of attributes that are needed to manage the entities that hold the
   ;; attributes being edited.
   :form-fields        #{::acct/id ::acct/name}
   :query              [:ui/new? [::uism/asm-id '_] ::acct/id ::acct/name]
   :ident              ::acct/id}
  (form/render-form this props))

(defsc AccountListItem [this {::acct/keys [id name] :as props}]
  {::attr/attributes [acct/id acct/name]

   ;; Can be autogenerated:
   :query            [::acct/id ::acct/name]
   :ident            ::acct/id}

  ;; Could be autogenerated
  (dom/div :.item
    (div :.content
      (dom/a :.header {:onClick (fn []
                                  ;; TODO: Edit link
                                  )}
        "Name: " name))))

(def ui-account-list-item (comp/factory AccountListItem {:keyfn ::acct/id}))

(defsc AccountList [this {:keys [::acct/all-accounts] :as props}]
  {::rad/list-item        AccountListItem
   ::rad/source-attribute ::acct/all-accounts

   :route-segment         ["accounts"]

   ;; This can be autogenerated, but it could also be overloaded
   ::rad/load!            (fn [app {::rad/keys [target-route] :as options}]
                            (log/info "Loading all accounts")
                            (df/load! app ::acct/all-accounts AccountListItem
                              (merge
                                options
                                {:post-action (fn [{:keys [app]}] (controller/io-complete! app target-route))
                                 :target      [:component/id ::account-list ::acct/all-accounts]})))

   ;; Our macro can generate these:
   :query                 [{::acct/all-accounts (comp/get-query AccountListItem)}]
   :ident                 (fn [] [:component/id ::account-list])}
  ;; Body could be auto-generated
  (dom/div :.ui.middle.aligned.divided.list
    (map ui-account-list-item all-accounts)))

(def ui-account-list (comp/factory AccountList))

(defsc LandingPage [this props]
  {:query         ['*]
   :ident         (fn [] [:component/id ::LandingPage])
   :initial-state {}
   :route-segment ["landing-page"]}
  (dom/div "Hello World"))

;; This will just be a normal router...but there can be many of them.
(defrouter CRUDController [this props]
  {:router-targets [LandingPage AccountList AccountForm]})

(def ui-crud-controller (comp/factory CRUDController))

;; TODO: This will be a macro or function that generates this
;; TODO: Composition of auth provider UI into this controller
(defsc AuthController [this {:ui/keys [auth-context] :as props}]
  ;; TODO: query is generated from the authentication providers
  {:query                          [:ui/auth-context
                                    {:local (comp/get-query LoginForm)}
                                    [::uism/asm-id '_]]
   ::auth/authentication-providers {:local LoginForm}
   :ident                          (fn [] [:component/id ::AuthController])
   :initial-state                  {:local           {}
                                    :ui/auth-context nil}}
  ;; TODO: Logic to choose the correct factory for the provider being used
  (let [state           (uism/get-active-state this auth/machine-id)
        authenticating? (= :state/gathering-credentials state)
        {:keys [local]} props
        factory         (comp/computed-factory LoginForm)]
    (factory local {:visible? authenticating?})))

(def ui-auth-controller (comp/factory AuthController {:keyfn :id}))

(defsc Root [this {:keys [auth-controller crud-controller]}]
  {:query         [{:auth-controller (comp/get-query AuthController)}
                   {:crud-controller (comp/get-query CRUDController)}]
   :initial-state {:crud-controller {}
                   :auth-controller {}}}
  (dom/div
    (div :.ui.top.menu
      (div :.ui.item "Demo Application")
      (dom/a :.ui.item {:onClick (fn []
                                   (controller/route-to! this ["accounts" "all"]))} "Accounts"))
    (div :.ui.container.segment
      (ui-auth-controller auth-controller)
      (ui-crud-controller crud-controller))))

(def ui-root (comp/factory Root))

