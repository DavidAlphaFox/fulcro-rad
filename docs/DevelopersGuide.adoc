= Fulcro Developers Guide
:author: Tony Kay
:revdate: December 8, 2019
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc: left
:toclevels: 2
:sectlinks:
:sectanchors:
:leveloffset: 1
:sectnums:
:imagesdir: /assets/img
:scriptsdir: js
:imagesoutdir: assets/img
:favicon: assets/favicon.ico

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
toc::[]
endif::[]

++++
<style>
@media screen {
  button.inspector {
    float: right;
    right: 0px;
    font-size: 10pt;
    margin-bottom: 6px;
    padding: 6px;
    border-radius: 14px;
  }
}
@media print {
  button.inspector {display: none;}
}
.example {
  clear: both;
  margin-left: auto;
  margin-right: auto;
  position: relative;
  min-height: 400px;
  background-color: lightgray;
  border: 3px groove white;
  border-radius: 5px;
  padding: 5px;
}
.narrow.example { width: 50%; }
.wide.example { width: 80%; }
.short.example { min-height: 200px; }
.tall.example { min-height: 800px; }
</style>
++++

= Introduction

WARNING: Fulcro RAD is in early stages of development. The documented features are somewhat stable
and should not change much over time; however, until RAD reaches a formal release (beyond an alpha)
we are not committed to maintaining the APIs with backward compatibility since that would slow our initial
development and could lock us into design decisions that have not been fully vetted. That said, the
overall central goals are well-known, and this should prevent it from being terribly difficult
to port an existing RAD app forward to a new version.

This book covers Rapid Application Development (RAD) tools for Fulcro.  The RAD system is intended to be augmented with
any number of plugins that can handle anything from back-end database management to front-end UI automation.

The core system has the following general ideals:

* Everything is optional.  Applications written using RAD should be able to choose which aspects are useful, and easily
escape from aspects if they don't fit their needs.
* Reasonable defaults and utilities for common needs.

The common features that are intended to be well-supported in early versions of the library include:

* Declarative and extensible data model.
* Reasonable defaults for CRUD interfaces (form generation) to arbitrary graphs of that data model, including to-one
and to-many relations.
* Reasonable defaults for common reporting needs, especially when tabular.
* An opt-in extensible authentication mechanism.

RAD is currently of pre-alpha quality, and should be used with caution.

== Attribute-Centric

Fulcro encourages the use of a graph-based data model that is agnostic to the underlying representation of your data.
This turns out to be a quite powerful abstraction, as it frees you from the general limitations and restrictions of a
rigid class/table-based schema while still giving you adequate structure for your data model.

The central artifact that you write when building with RAD is an *attribute*, which is an RDF-style concept where you
define everything of interest about a particular fact in the world in a common map.  The only two required things that
you must say about an attribute are a distinct name and a distinct type.  The *name* must be a
fully-qualified keyword.  The namespace should be distinct enough to co-exist in the data realm of your application
(i.e. if you are working on the internet level you should consider using domain-style naming).
The *type* must be a data type that is supported by your database back-end.  The type system of RAD is extensible, and
you must refer to the documentation of your selected database adapter and rendering layer to find out if the data type
is already supported.  It is generally easy to extend the data type support of RAD.

A minimal attribute will look something like this:

[source,clojure]
----
(ns com.example.model.item (:require
    [com.fulcrologic.rad.attributes :as attr :refer [defattr]]))

(defattr id :item/id :uuid 
  {::attr/identity? true 
   :com.fulcrologic.rad.database-adapters.datomic/schema :production})
----

The `defattr` macro really just assigns a plain map to the provided symbol (`id` in this case), but it also ensures that
you've provided a name for the attribute (`:item/id` in this case), and a type.  It is exactly equivalent to:

[source,clojure]
----
(def id {::attr/qualified-key :item/id 
         ::attr/type :uuid 
         ::attr/identity? true 
         :com.fulcrologic.rad.database-adapters.datomic/schema :production})
----

The various plugins and facilities of RAD define keys that allow you to describe how your new data attribute should
behave in the system.  In the example above the `identity?` marker indicates that the attribute identifies groups of
other facts (is a primary key for data), and the datomic-namespaced `schema` is used by the Datomic database plugin to
indicate the schema that the attribute should be associated with.

=== Extensibility

Attributes are represented as open maps (you can add your own namespaced key/value pairs).  There are a core set of keys
that the core library defines for generalized use, but most plugins will use keywords namespaced to their library to
extend the configuration stored on attributes.  These keys can define anything, and form the central feature of RAD's
extensibility.

== Data Modelling, Storage, and API

The attribute definitions are intended to be *usable* by server storage layers to auto-generate artifacts like schema,
network APIs, documentation, etc.  Of course these things are all optional, but can serve as a great time-saver when
standing up new applications.

=== Schema Generation

Attributes are intended to be capable of completely describing the data model.  Database plugins will often be capable
of using the attributes to generate server schema.  Typical plugins will require library-specific keys that will tell
you how to get exactly the schema you want.  If you're working with a pre-existing database you will probably not bother
with this aspect of RAD.

=== Resolvers

Resolvers are part of the pathom library.  Resolvers figure out how to get from a context to data that is needed by the
client.  Attributes describe the data model, so storage plugins can usually generate resolvers and provide a base EQL
API for your data model.  All you have to do is hook it into your server's middleware.

=== Security

Statements about security can also be co-located on attributes, which means that RAD can generate protections around
your data model.

== Forms

Many features of web applications can be classified as some kind of form.  For our purposes a form is a UI for a group
of attributes that are persisted in a long-term storage.  A form could be anything from a simple set of input fields to
a kanban board.  Most applications have the need to generate quite a few simple forms around the base data model in
order to do customer support and general data administration.  Simple forms are also a common feature in user-facing
content.

RAD has a pluggable system for generating simple forms, but it can also let you take complete control of the UI while
RAD still manages the reads, writes, and overall security of the data.

Forms in RAD are a mechanism around reading and writing specific sub-graphs of your data model.

== Reports

Reports are similar to forms, but are not about writing anything in the data model: they are about pulling data from
your data model.  They may include derived data, aggregations, etc.

You typical report will have:

* Input Parameters
* A query for the results
* A UI, often tabular.

Most reports are generated by adding additional pathom resolvers to your model, so that you can simply query for the
various facets that your report needs.

Report plugins should be able to provide just about anything you can imagine in the context of a report, such as:

* Parameter Inputs
* Linkage to forms for editing
* Graphs/charts
* Tabular reports

The RAD system generally makes it easy for you to pull the raw data for a report, and at any moment you can also choose
to do the specific rendering for the report when no plugin exists that works for your needs.

== Platform Targets

Fulcro works quite well on the web, in React Native, and in Electron.  Notice that the core of RAD is built around
auto-generation of UI, meaning that many features of RAD will work equally well in any of these settings.

= Attributes  [[Attributes]]

The recommended setup of attributes is as follows:

* Create a `model` package, such as `com.yourcompany.model`.
* Organize your attributes around the concepts and entities that use them.
** Try *not* to think of attributes as _strictly_ belonging to an *entity* or *table* so much as describing a particular fact. For
example the attribute `:password/hashed-value` might live on a `File` or `Account` entity. Entity-centric attributes
certainly exist, but you should not constrain your thinking about them.
* Place attributes in a namespace that most closely represents the concept/entity for that attribute. For example
`com.yourcompany.model.account`. Use CLJC!
* At the end of each file include a `def` for `attributes` and `resolvers`. Each should be a vector containing
all of the attributes and Pathom resolvers defined in that file.
* Create a central model namespace that has all attributes. I.e. `com/yourcompany/model.cljc` containing
a `def` for `all-attributes`.

== Model Namespaces

The first thing you'll typically create will be namespaces like this:

[source]
-----
(ns com.example.model.account
  (:require
    [com.fulcrologic.rad.attributes :as attr :refer [defattr]]))

(defattr id :account/id :uuid
  {::attr/identity? true})

(defattr name :account/name :string
  {::attr/required? true})

(def attributes [id name])
(def resolvers [])
-----

The namespace makes it easy for you to find the attributes when you want to read all of the details
about them, and the final `def` make it easy to combine the declared attributes into a single
collection for use in APIs that need to know them all.

== Identity Attributes

Each type of entity/table/document in your database will need a primary key.  Each attribute that you
define that acts as a primary key will serve as a way to contextually find attributes that indicate
they can be found via that key.  This is very similar to what you're used to in typical databases where
a primary key gives you, say, a row.  RAD's data model does not constrain an attribute to live in just
one place, as you'll see in a moment.

The `::attr/identity?` boolean marker on an attribute marks it as a "primary key" (really that it is
a key by which a distinct entity/row/document can be found).

[source]
-----
(ns com.example.model.account
  (:require
    [com.fulcrologic.rad.attributes :as attr :refer [defattr]))

(defattr id :account/id :uuid
  {::attr/identity?                                      true})
-----

== Scalar Attributes

Many attributes are simple containers for scalar values (strings, numbers, etc.). RAD itself does not
constrain where an attribute can live in any way, but specific database adapters will have rules
that match the underlying storage technology.

A RAD attribute to store a string might look like this:

[source]
-----
(defattr id :account/name :string
  {})
-----

but such an attribute only be usable if you hand-generate resolvers on your server that can obtain
the value, and can store it based on the ID you give a form.  So, such an attribute isn't useless,
but it is made much more powerful when you add data for other plugins.

== Attribute Clusters (Entities/Tables/Documents)

RAD itself does not define how attributes cluster together (in tables/documents/entities), since that
is database-specific. For example, Datomic uses entities that have a single `:db/id` attribute, but
users often use a domain-specific UUID attribute to obtain certain modelling advantages.

So, plugins like database adapters will have you add data to an attribute that informs it of your intended
(or existing) database organization. This allows the database adapter to figure out how to do things like
generate query resolvers, generate save logic for forms, check schema conformance, autogenerate schema, etc.

Here is how the Datomic database adapter would have you define things to cluster "account" attributes
into an account entity:

[source]
-----
(ns com.example.model.account
  (:refer-clojure :exclude [name])
  (:require
    #?@(:clj
        [[com.wsscode.pathom.connect :as pc :refer [defmutation]]
         [com.example.model.authorization :as exauth]
         [com.example.components.database-queries :as queries]]
        :cljs
        [[com.fulcrologic.fulcro.mutations :as m :refer [defmutation]]])
    [clojure.string :as str]
    [com.wsscode.pathom.connect :as pc]
    [com.fulcrologic.rad.form :as form]
    [com.fulcrologic.rad.attributes :as attr :refer [defattr]]
    [com.fulcrologic.rad.authorization :as auth]
    [taoensso.timbre :as log]
    [com.fulcrologic.rad.type-support.date-time :as datetime]))

(defattr id :account/id :uuid
  {::attr/identity?                                      true})

(defattr name :account/name :string
  {:com.fulcrologic.rad.database-adapters.datomic/entity-ids #{:account/id}
   ::attr/required?                                          true})
-----

In this case the Datomic adapter defines a plugin-namespaced key (`entity-ids`) which takes a set of "primary keys" that
can be used to find an attribute. This has the effect of "placing" `:account/name` on entities that can be found by
`:account/id`.  Note that this allows an attribute to exist on any number of entity "types", which is in alignment
with the flexible nature of Datomic.

A document database like Firebase might do a similar thing, but a more stringent schema-based system like SQL might
lead you more towards declaring things that map to well-known tables (through RAD can easily adapt such systems
into a more flexible attribute model).

== Referential Attributes

Data models are typically normalized, and normalization requires that you be able to store a distinct thing once
and refer to it from other places.  RAD's attribute-centric nature actually gives you quite a bit of ability
to "flex" the shape of your data model at runtime through custom resolvers (i.e. you can create virtualized
views of your data that have alternate shapes from the way the data is stored).  Therefore the reference declarations
in RAD can define a concrete (i.e. represented in storage) or virtual link.

If an attribute represents a concrete link in storage then it will include database adapter-specific entries that
define that linkage. If an attribute represents a virtual link it will typically include a lambda (resolver) that
runs the appropriate logic to "invent" that linkage. For example, your customers might have multiple addresses,
and you might want a virtual reference to the address you've most often shipped items to.  You can easily
assign that a name like `:customer/most-likely-address`, but you'll most likely need to run a query of order history
to actually figure out what that is.

References have a cardinality (one/many), and when they are concrete they also typically have some kind of optional
statement about "ownership". In SQL this is typically modelled with `CASCADE` rules, in document databases it is
often implied by co-location in the same document, and in Datomic it is handled with the `isComponent` flag.

Again, RAD attributes allow the database adapter to define namespaced keys that can be placed on an attribute
to indicate how that attribute should behave.

When using references in Forms you'll typically have to include a bit of extra information to the form itself for
it to know which kind of behavior should be modelled for the user.
For example an invoice's line item needs to point to something defined in your inventory. An invoice form might show that
as a dropdown that lets you autocomplete a selection from the inventory items.

== Attribute Types and Details

There are a number of predefined attribute types and information markers that are defined by the central RAD system.
Each add-on or plugin can define any number of additional namespaced keys that could also be declared on an attribute.

The supported attribute types include:

`:string`:: A variable-length string.
`:enum `:: An enumerated list of values. Support varies by db adapter.
`:boolean`:: true/false
`:int`:: A (typically 32-bit) integer
`:long`:: A (typically 64-bit) integer
`:decimal`:: An arbitrary-precision decimal number. Stored precision is up to the db adapter.
`:instant`:: A binary UTC timestamp.
`:keyword`:: An EDN keyword
`:symbol`:: An EDN symbol
`:ref`:: A reference to another entity/table/document. Indicates traversal of the attribute graph.
`:uuid`:: A UUID.

The following additional keys can be placed in the attribute map:

`::attr/identity?`:: A boolean. When true it indicates that this attribute can be used as a PK to find
an entity/document/table row.
`::attr/required?`:: A boolean. Indicates that the system should constrain interactions such that
entities/rows/documents that contain this attribute are considered invalid if they do not have it.
Affects things like schema generation, form interactions, etc.
`::attr/target`:: A keyword. Required when the type of the attribute is `:ref`. It must be the qualified keyword
name of the attribute that can be used to look up instances of the target of the ref. For example
`:account/addresses` might have a target of `:address/id`.
`::attr/cardinality`:: Required when the type of the attribute is `:ref`.
Either :one or :many. Defines the expected cardinality of the relation.
`::attr/enumerated-values`:: Only when type is `:enum`. A set of keywords that represent the legal possible values when the
   type is `:enum`. Constraints on this may vary based on the db adapter chosen.
`::attr/enumerated-labels`:: Only when type is `:enum`. A map from enumerated keywords (in `enumerated-values`) to the
user string that should be shown for that enumerated value. Used in Form UI generation.

== All Attributes

There is a central attribute registry that you must set up for proper overall operation. We are in the
process of phasing this out.  In the meantime many of the APIs require a list of all of the attributes
in the system. If you've followed our recommendation of including a `def` of `attributes` at the
bottom of each model namespace, then you can easily create this like so:

[source]
-----
(ns com.example.model
  (:require
    [com.example.model.account :as account]
    [com.example.model.item :as item]
    [com.example.model.invoice :as invoice]
    [com.example.model.line-item :as line-item]
    [com.example.model.address :as address]
    [com.fulcrologic.rad.attributes :as attr]))

(def all-attributes (vec (concat
                           account/attributes
                           address/attributes
                           item/attributes
                           invoice/attributes
                           line-item/attributes)))
-----

= Database Adapters

Database adapters are an optional part of the RAD system. There are really three main features that
a given database adapter MAY provide for you (none are required). The may provide the ability to:

. Auto-generate schema for the real database.
. Generate a network API to read the database for the UI client.
. Process form saves (which come in a standard diff format).

Additional features, of course, could be supplied such as the ability to:

. Validate the attribute definitions against an existing (i.e. legacy) schema.
. Shard across multiple database servers.
. Pool database network connections.
. Isolate development changes from the real database (i.e. database interaction mocking)

== The Datomic Adapter

The RAD Datomic database adapter has the following features:

. Datomic Schema generation from attributes.
. Support for multiple database schemas.
. Form save automation.
. Automatic generation of a full network API that can pull from the database(s).
. Database sharding.

=== Configuration

Configuring the Datomic adapter currently requires Datomic on-prem (free or starter). Cloud support
is planned but not written. The elements to configure are:

. Add your database definitions to your application config.
. Start the adapter when your server starts, and save the result.
. Add the auto-generated resolvers into your API parser.
. Add the normal RAD form handlers (save/delete) into your API parser.
. Insert the datomic env into your parser env (which adds support for save), which must also resolve
the correct database connection(s) (shard/schema) for the incoming request using the request details and
the result from (2).

This sounds like a long list, but each is typically just a line or two of code.

==== Application Configuration for Datomic

The database configuration looks like this:

[source]
-----
 :com.fulcrologic.rad.database-adapters.datomic/databases
                                    {:main {:datomic/schema           :production
                                            :datomic/driver           :postgresql
                                            :datomic/database         "example"
                                            :datomic/prevent-changes? true
                                            :postgresql/host          "localhost"
                                            :postgresql/port          5432
                                            :postgresql/user          "datomic"
                                            :postgresql/password      "datomic"
                                            :postgresql/database      "datomic"}}
-----

The keys of the map are the shard name (in this case there is only one real database and schema). Each
shard must name which `:datomic/schema` it is intended to provide, which in turn must match a
`::datomic/schema` entry on attributes:

[source]
-----
;; This attribute lives in the production schema
(defattr id :address/id :uuid
  {::attr/identity?                                      true
   :com.fulcrologic.rad.database-adapters.datomic/schema :production})
-----

If you wanted to have multiple databases with the same schema you'd just have multiple shard names
in the map as keys, and database connection details as the values.

==== Starting the Database Adapter

If you're using `mount`, then starting the database adapter is as simple as:

[source]
-----
(ns com.example.components.datomic
  (:require
    [com.fulcrologic.rad.database-adapters.datomic :as datomic]
    [mount.core :refer [defstate]]
    [com.example.model :refer [all-attributes]]
    [com.example.components.config :refer [config]]))

(defstate ^{:on-reload :noop} datomic-connections
  :start
  (datomic/start-databases all-attributes config))
-----

The call needs a flat vector of all attribute definition in the system, and the config (as shown
in the prior section). It does the following things, according to the configutation:

* Connects to the databases
* Optionally wraps the connections with a mocked connection so that no changes persist to the real
database (useful during development).
* Optionally generates schema for each.
* Optionally applies schema to each.

It returns a map from database name (i.e. `:main`) to Datomic connections.

==== Add Generated Resolvers

Your application will have a combination of auto-generated resolvers. Some might come from
pure attribute definitions, and others will come from adapters like this one. Typically
you'll combine them all in some central stateful place, like this:

[source]
-----
(ns com.example.components.auto-resolvers
  (:require
    [com.example.model :refer [all-attributes]]
    [mount.core :refer [defstate]]
    [com.fulcrologic.rad.resolvers :as res]
    [com.fulcrologic.rad.database-adapters.datomic :as datomic]
    [taoensso.timbre :as log]))

(defstate automatic-resolvers
  :start
  (vec
    (concat
      (res/generate-resolvers all-attributes)
      (datomic/generate-resolvers all-attributes :production))))
-----

Again note the use of the `all-attributes`, which is simply a collection of all of your
various attribute definitions.

==== Set up The Parser

You will be generating a Pathom parser on your back-end. You must modify it to include

TODO: finish describing

[source]
-----
(ns com.example.components.parser
  (:require
    [com.example.components.auto-resolvers :refer [automatic-resolvers]]
    [com.example.components.config :refer [config]]
    [com.example.components.datomic :refer [datomic-connections]]
    [com.fulcrologic.rad.database-adapters.datomic :as datomic]
    [com.fulcrologic.rad.pathom :as pathom]
    [mount.core :refer [defstate]]
    [datomic.api :as d]
    [com.fulcrologic.rad.form :as form]
    [com.example.model.account :as account]))

(defstate parser
  :start
  (pathom/new-parser config
    (fn [env]
      (-> env
        ;; you must create a map from SCHEMA name to the database that should serve that
        ;; schema for this request.
        (datomic/add-datomic-env {:production (:main datomic-connections)})))
    [automatic-resolvers
     ;; Standard form hooks, which know how to use database adapter handlers
     form/save-form
     form/delete-entity
     ...]))
-----

= Forms

Forms are a central element of Fulcro. A form:

* is a route target in Fulcro's dynamic routing system.
* has automatic state management, and runs a state machine while on screen.
* Is itself a Fulcro and React component.
* Uses attribute definitions, local form declarations, and pluggable UI to optionally auto-generate UI.
* Uses a standard mutation and delta format for saves, so that persistence is trivial across data storage
technologies.

== Setup

In order to get a basic form working in RAD you need the following:

* Declarations of the attributes that will be part of the form
* Resolvers that can pull that form's data from the server (usually auto-generated from a db plugin).
* A save mutation that can save the form (pre-defined, but requires a handler for each database, which is typically
supplied by a db plugin).
* (optional) Configuration of the ui rendering to auto-generate the UI (you may also hand-design the UI with
normal Fulcro/React code).
* (optional) Code that sets the time zone (usually based on the active user's session) if you will be storing
date/times in your database.
* (optional) Transit readers/writers for all extended data types that you wish to use.

The server-side operation of the form is largely handled by a storage plugin and normal Fulcro plumbing, as shown in
the demo project.

=== The Attributes

The attributes are a global resource defined in CLJC files, as described in the <<Attributes>> section of the book. You
will typically have one namespace for each cluster of attributes (typically around entities), where each attribute
defines a minimum of its type and qualified key:

[source]
----
(ns project.account

(defattr id :account/id :uuid
  {})

(defattr name :account/name :string
  {})
----

=== The Resolvers

Resolvers are Pathom Resolvers that can pull the data of interest from your database. Typically you'll have one
resolver for each top-level entity that can be pulled by ID, and custom resolvers that can satisfy various other
queries (e.g. all accounts, current user, etc.). Forms need to be able to at least resolve entities by
their ID.

=== Save Mutation

The form system comes with a built-in save mutation which you should install on your pathom parser (see the demo). This
save mutation delegates the actual saves to registered database handlers, and typically requires nothing more than
simple configuration.

== Making a Form

A minimal form that is using the maximal amount of RAD plugins and automation is quite small:

[source]
----
(form/defsc-form AccountForm [this props]
  {::form/id                account/id
   ::form/attributes        [account/name]
   ::form/cancel-route      (dr/path-to LandingPage)
   ::form/route-prefix      "address"})
----

The keys shown are required and define:

`::form/id`:: The actual attribute (defattr symbol, not keyword) definition of an identity attribute that acts as
the unique identifier of the entity in which the form data is stored.
`::form/attributes`:: The attributes that should be shown in the form.
`::form/cancel-route`:: A Fulcro dynamic route (absolute) that should be shown if the user cancels out of the form.
`::form/route-prefix`:: A string that will be used to generate the Fulcro routes for this form. The routes will
be `prefix/create/new-id` and `prefix/edit/existing-id`.

If you wish to create a new account, you need simple use Fulcro's `change-route` to go to this form:
`(dr/change-route (dr/path-to AccountForm {:action form/create-action
                                           :id (random-uuid)}))`

There are pre-written functions in the `form` ns for the common actions:

`(form/create! app-ish FormClass)`:: Create a new instance of an entity using the given form class.
`(form/edit! app-ish FormClass id)`:: Edit the given entity with `id` using `FormClass`
`(form/delete! app-ish qualified-id-keyword id)`:: Delete an entity.

Of course you'll also need to configure the overall application and make a root with a top-level router. See the
demo application for a complete example.

== Authorization and Validation

There are several places in form support that you may want to do a security or data validation when working with forms.

First, we could consider the three broadest categories by which we might constrain action:

. Read: Which things in the form should be visible to the given user.
. Write: Which things in the form the user is allowed to change, along with enforcing valid values.
. Execution (routing): Is the user even allowed to "run" the form (route to it)?

Of course there are always both the client and server contexts for these concerns.  Going to a form in the server
context is both a top-level and granular read restriction, whereas displaying a form in the client layer is both a UI
routing and form field visibility/interaction concern.

Ultimately there is an aspect of _granularity_: an entire route might be constrained, or a single property on a form
(e.g. a password should only be editable by an admin or the proven owner of the account).

All of these aspects of authorization and validation are meant to be declaratively controlled in RAD, but that control
is meant to be generally extensible.  Therefore authorization and validation middleware can be augmented and installed
at the following locations in the RAD stack:

* At the Ring middleware layer (standard Ring security).
* At the UI routing layer.
* At the global parser layer.
* At the individual attribute resolver and mutation layer.
* In the form save pipeline (both at the complete form and field granularity).

Pre-written plugins for forms give you pre-written functionality, but writing your own plugin for any one of these
layers allows you to customize these aspects as much as you desire.

We won't be covering Ring middleware in this book, since that is well-documented elsewhere.

=== UI Routing Middleware

WARNING: Not yet implemented

When you define a form using `defsc-form` you end up creating a routing target in Fulcro's dynamic routing system.  The
`:will-enter` handler is automatically supplied for you, and runs the various operations necessary for starting up a
state machine on the form and completing the route.

RAD's form system has an optional routing middleware system that can be configured to do client-side authorization tasks
that can prevent (or redirect) routing.  This middleware has access to the state map, the target form. and the target
route.  Individual forms can override this middleware on a per-component basis with the `::form/routing-middleware` key.

=== Parser-level Validation and Authorization

You can add middleware to the pathom parser in RAD that analyze the overall query or mutation being processed, and
modify the outcome in any way.  This is a standard Pathom feature.

=== Resolver and Mutation validation

Auto-generated resolvers and mutations use ...

Of course when you hand-write a resolver or mutation you can leverage attribute definitions, the `env`, and anything
else to determine the validity of the operation in question.

=== Form Validation/Authorization

WARNING: Not yet implemented

Individual fields are represented by one (or a small group) of attributes.  Those attributes are a great location to
place things like data specifications, user-facing validation checks, etc.

The form save mechanism in RAD has a standard server-side entry point that splits off an incoming save across any number
of low-level database adapters.  You can install middleware that sits between these two (the entry point and actual
save).  Such middleware can redact information, reject invalid requests, verify security, etc.

== UI Validation

The data type and rendering style of an attribute (along with extended parameters defined by input syltes) are the first
line of UI validation: Saying that something is a decimal number with a US currency style will already ensure that the
user cannot input "abc" into the field.

Further constraining the value might be something you can say at the general attribute level (`age` must be between 0
and 130), or may be contextual within a specific form (`from-date` must be before `to-date`).

Validators are functions as described in http://book.fulcrologic.com/#CustomValidators[Fulcro's Form State support]:
They are functions that return `:valid`, `:invalid`, or `:unknown` (the field isn't ready to be checked yet).
They are easily constructed using the `form-state/make-validator` helper, which takes into account the current completion
marker on the field itself (which prevents validation messages from showing too early).

Attribute-level validation checks are specified with a predicate:

[source]
----
(defattr name :account/name :string
  {::attr/valid? (fn [nm] (boolean (seq nm)))})
----

Custom validations are defined at the form level with the `::form/validator` key.  If there are validators at both
layers then the form one *completely overrides all attribute validators*. If you want to compose validators from
the attributes then use `attr/make-attribute-validator` on your complete model, and use the result in the form validator:

[source]
----
(ns model ...)

(def all-attributes (concat account/attributes ...)
(def all-attribute-validator (attr/make-attribute-validator all-attributes))

...

(ns account)

(def account-validator (fs/make-validator (fn [form field]
                                            (case field
                                              :account/email (str/ends-with? (get form field) "example.com")
                                              (= :valid (model/all-attribute-validator form field))))))
----

The message shown to the user for an invalid field is also configurable at the form or attribute level.
The existence of a message on the form _overrides_ the message declared on the attribute.

[source]
----
(attr/defattr age :thing/age :int
  ::attr/validation-message (fn [age]
                              (str "Age must be between 0 and 130.")))

...

(form/defsc-form ThingForm [this props]
  {::form/validation-messages
   {:thing/age (fn [form-props k]
                 (str (get form-props k) " is an invalid age."))}
   ...})
----

The form-based overrides are useful when you have dependencies between fields, since they can consider all of the
data in the form at once and incorporate it into the check and validation message. For example you might want to
require a new email user use their lower-case first name as a prefix for an email address you're going to generate
in your system. You might use something like this:

[source]
----
(def account-validator (fs/make-validator (fn [form field]
                                            (case field
                                              :account/email (let [prefix (or
                                                                            (some-> form
                                                                              (get :account/name)
                                                                              (str/split #"\s")
                                                                              (first)
                                                                              (str/lower-case))
                                                                            "")]
                                                               (str/starts-with? (get form :account/email) prefix))
                                              (= :valid (model/all-attribute-validator form field))))))
----

== Composing Forms

It is quite common for a form to cover more than one entity (row or document) in a database. An account might have
one or more addresses. An invoice has a customer, line items, and references to inventory. In RAD, combining related
data requires a form definition for each uniquely identifiable entity/row/document. These can have to-one or to-many
relationships.

A given entity and its related data can be joined together into a single form interaction by making one of the forms
the master. This must be a form that resolves to a single entity, and whose subforms are reachable by resolvers through
the attributes of that master (or descendants).

Any form can automatically serve as a master. The master is simply selected by routing to it, since that will start
that form's state machine which in turn will end up controlling the entire interaction.  The subforms themselves can
act as standalone forms, but will not be running their own state machine unless you route directly to them. Interestingly
this means that forms can have both a sibling and parent-child relationship in your application's UI graph.

All forms are typically added to a top-level router so that each kind of entity can be worked with in isolation. However,
some forms may also make sense to use a subforms within the context of others. An example might be an `AddressForm`. While
it might make sense to allow someone to edit an address in isolation, the address itself probably belongs to some other
entity that may wish to allow editing of that sub-entity in its context.

A simple example of this would look as follows:

[source]
-----
(form/defsc-form AddressForm [this props]
  {::form/id                address/id
   ::form/attributes        [address/street address/city address/state address/zip]
   ::form/cancel-route      ["landing-page"]
   ::form/route-prefix      "address"
   ::form/title             "Edit Address"})

(form/defsc-form AccountForm [this props]
  {::form/id                  acct/id
   ::form/attributes          [acct/name acct/email acct/active? acct/addresses]
   ::form/cancel-route        ["landing-page"]
   ::form/route-prefix        "account"
   ::form/title               "Edit Account"
   ::form/subforms            {:account/addresses {::form/ui              AddressForm}}})

(defrouter MainRouter [this props]
  {:router-targets [AccountForm AddressForm]})
-----

In the above example the `AddressForm` is completely usable to edit an address (if you have an ID) or create one
(if it makes sense to your application to create one in isolation). But it is also used as a subform through the
`:account/addresses` attribute where the `::form/subforms` map is used to configure which form should be used for
the items of the to-many relationship. Additional keys in the `subforms` map entries allow for specific behavioral
support.

=== Relationship Lifecycle

One of the core questions in any relation is: does the referring entity/table/document "own" the target?  In other words
does it create and destroy it?  When there is a graph of such relations this question is also recursive (and is handled by things
like cascade definitions in SQL and isComponent markers in Datomic).

When there is not an ownership relation one still needs to know if the referring entity is allowed to create new ones
(destroying them is usually ruled out, since others could be using it).

In the cases where there is not an ownership relation we usually model it as some kind of "picker" in a form, allowing
the user to simply select (or search for) "which" of the existing targets are desired. When there is an ownership
relation the form will usually model the items as editable sub-forms, with optional controls that allow the
addition and removal of the elements in the relation.

=== To-One Relationships


=== To-Many Relationships
